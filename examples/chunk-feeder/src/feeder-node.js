/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["FeederNode"] = factory();
	else
		root["FeederNode"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@alexanderolsen/libsamplerate-js/dist/libsamplerate.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@alexanderolsen/libsamplerate-js/dist/libsamplerate.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("!function(n,r){ true?module.exports=r():0}(self,(function(){return(()=>{var n={17:(n,r,e)=>{var t;function o(n){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&\"function\"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?\"symbol\":typeof n})(n)}n=e.nmd(n);var i,a=(i=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(n){var r,e,t=void 0!==(n=n||{})?n:{};t.ready=new Promise((function(n,t){r=n,e=t}));var a,u={};for(a in t)t.hasOwnProperty(a)&&(u[a]=t[a]);var f=[],c=function(n,r){throw r},l=\"\";\"undefined\"!=typeof document&&document.currentScript&&(l=document.currentScript.src),i&&(l=i),l=0!==l.indexOf(\"blob:\")?l.substr(0,l.lastIndexOf(\"/\")+1):\"\",t.print||console.log.bind(console);var s,d,p,h=t.printErr||console.warn.bind(console);for(a in u)u.hasOwnProperty(a)&&(t[a]=u[a]);u=null,t.arguments&&(f=t.arguments),t.thisProgram&&t.thisProgram,t.quit&&(c=t.quit),t.wasmBinary&&(s=t.wasmBinary),t.noExitRuntime&&(d=t.noExitRuntime),\"object\"!==(\"undefined\"==typeof WebAssembly?\"undefined\":o(WebAssembly))&&V(\"no native wasm support detected\");var v=!1,y=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function m(n,r){return n?function(n,r,e){for(var t=r+e,o=r;n[o]&&!(o>=t);)++o;if(o-r>16&&n.subarray&&y)return y.decode(n.subarray(r,o));for(var i=\"\";r<o;){var a=n[r++];if(128&a){var u=63&n[r++];if(192!=(224&a)){var f=63&n[r++];if((a=224==(240&a)?(15&a)<<12|u<<6|f:(7&a)<<18|u<<12|f<<6|63&n[r++])<65536)i+=String.fromCharCode(a);else{var c=a-65536;i+=String.fromCharCode(55296|c>>10,56320|1023&c)}}else i+=String.fromCharCode((31&a)<<6|u)}else i+=String.fromCharCode(a)}return i}(b,n,r):\"\"}var g,w,b,_,A,T,S,C,E,R=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf-16le\"):void 0;function P(n,r){for(var e=n,t=e>>1,o=t+r/2;!(t>=o)&&A[t];)++t;if((e=t<<1)-n>32&&R)return R.decode(b.subarray(n,e));for(var i=\"\",a=0;!(a>=r/2);++a){var u=_[n+2*a>>1];if(0==u)break;i+=String.fromCharCode(u)}return i}function k(n,r,e){if(void 0===e&&(e=2147483647),e<2)return 0;for(var t=r,o=(e-=2)<2*n.length?e/2:n.length,i=0;i<o;++i){var a=n.charCodeAt(i);_[r>>1]=a,r+=2}return _[r>>1]=0,r-t}function W(n){return 2*n.length}function I(n,r){for(var e=0,t=\"\";!(e>=r/4);){var o=T[n+4*e>>2];if(0==o)break;if(++e,o>=65536){var i=o-65536;t+=String.fromCharCode(55296|i>>10,56320|1023&i)}else t+=String.fromCharCode(o)}return t}function F(n,r,e){if(void 0===e&&(e=2147483647),e<4)return 0;for(var t=r,o=t+e-4,i=0;i<n.length;++i){var a=n.charCodeAt(i);if(a>=55296&&a<=57343&&(a=65536+((1023&a)<<10)|1023&n.charCodeAt(++i)),T[r>>2]=a,(r+=4)+4>o)break}return T[r>>2]=0,r-t}function x(n){for(var r=0,e=0;e<n.length;++e){var t=n.charCodeAt(e);t>=55296&&t<=57343&&++e,r+=4}return r}function O(n){g=n,t.HEAP8=w=new Int8Array(n),t.HEAP16=_=new Int16Array(n),t.HEAP32=T=new Int32Array(n),t.HEAPU8=b=new Uint8Array(n),t.HEAPU16=A=new Uint16Array(n),t.HEAPU32=S=new Uint32Array(n),t.HEAPF32=C=new Float32Array(n),t.HEAPF64=E=new Float64Array(n)}t.INITIAL_MEMORY;var U,j=[],D=[],M=[],B=[],N=0,L=null,H=null;function V(n){t.onAbort&&t.onAbort(n),h(n+=\"\"),v=!0,n=\"abort(\"+n+\"). Build with -s ASSERTIONS=1 for more info.\";var r=new WebAssembly.RuntimeError(n);throw e(r),r}function z(n){return r=n,e=\"data:application/octet-stream;base64,\",String.prototype.startsWith?r.startsWith(e):0===r.indexOf(e);var r,e}t.preloadedImages={},t.preloadedAudios={};var Y,q=\"glue.wasm\";function Q(n){try{if(n==q&&s)return new Uint8Array(s);throw\"both async and sync fetching of the wasm failed\"}catch(n){V(n)}}function Z(n){for(;n.length>0;){var r=n.shift();if(\"function\"!=typeof r){var e=r.func;\"number\"==typeof e?void 0===r.arg?U.get(e)():U.get(e)(r.arg):e(void 0===r.arg?null:r.arg)}else r(t)}}function J(n){switch(n){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(\"Unknown type size: \"+n)}}z(q)||(Y=q,q=t.locateFile?t.locateFile(Y,l):l+Y);var $=void 0;function G(n){for(var r=\"\",e=n;b[e];)r+=$[b[e++]];return r}var K={},X={},nn={};function rn(n){if(void 0===n)return\"_unknown\";var r=(n=n.replace(/[^a-zA-Z0-9_]/g,\"$\")).charCodeAt(0);return r>=48&&r<=57?\"_\"+n:n}function en(n,r){return n=rn(n),new Function(\"body\",\"return function \"+n+'() {\\n    \"use strict\";    return body.apply(this, arguments);\\n};\\n')(r)}function tn(n,r){var e=en(r,(function(n){this.name=r,this.message=n;var e=new Error(n).stack;void 0!==e&&(this.stack=this.toString()+\"\\n\"+e.replace(/^Error(:[^\\n]*)?\\n/,\"\"))}));return e.prototype=Object.create(n.prototype),e.prototype.constructor=e,e.prototype.toString=function(){return void 0===this.message?this.name:this.name+\": \"+this.message},e}var on=void 0;function an(n){throw new on(n)}var un=void 0;function fn(n){throw new un(n)}function cn(n,r,e){if(e=e||{},!(\"argPackAdvance\"in r))throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");var t=r.name;if(n||an('type \"'+t+'\" must have a positive integer typeid pointer'),X.hasOwnProperty(n)){if(e.ignoreDuplicateRegistrations)return;an(\"Cannot register type '\"+t+\"' twice\")}if(X[n]=r,delete nn[n],K.hasOwnProperty(n)){var o=K[n];delete K[n],o.forEach((function(n){n()}))}}var ln=[],sn=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function dn(n){n>4&&0==--sn[n].refcount&&(sn[n]=void 0,ln.push(n))}function pn(n){switch(n){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:var r=ln.length?ln.pop():sn.length;return sn[r]={refcount:1,value:n},r}}function hn(n){return this.fromWireType(S[n>>2])}function vn(n){if(null===n)return\"null\";var r=o(n);return\"object\"===r||\"array\"===r||\"function\"===r?n.toString():\"\"+n}function yn(n,r){switch(r){case 2:return function(n){return this.fromWireType(C[n>>2])};case 3:return function(n){return this.fromWireType(E[n>>3])};default:throw new TypeError(\"Unknown float type: \"+n)}}function mn(n){for(;n.length;){var r=n.pop();n.pop()(r)}}function gn(n,r,e){return-1!=n.indexOf(\"j\")?function(n,r,e){return e&&e.length?t[\"dynCall_\"+n].apply(null,[r].concat(e)):t[\"dynCall_\"+n].call(null,r)}(n,r,e):U.get(r).apply(null,e)}var wn=void 0;function bn(n){var r=Pn(n),e=G(r);return En(r),e}function _n(n,r,e){switch(r){case 0:return e?function(n){return w[n]}:function(n){return b[n]};case 1:return e?function(n){return _[n>>1]}:function(n){return A[n>>1]};case 2:return e?function(n){return T[n>>2]}:function(n){return S[n>>2]};default:throw new TypeError(\"Unknown integer type: \"+n)}}function An(n){try{return p.grow(n-g.byteLength+65535>>>16),O(p.buffer),1}catch(n){}}!function(){for(var n=new Array(256),r=0;r<256;++r)n[r]=String.fromCharCode(r);$=n}(),on=t.BindingError=tn(Error,\"BindingError\"),un=t.InternalError=tn(Error,\"InternalError\"),t.count_emval_handles=function(){for(var n=0,r=5;r<sn.length;++r)void 0!==sn[r]&&++n;return n},t.get_first_emval=function(){for(var n=5;n<sn.length;++n)if(void 0!==sn[n])return sn[n];return null},wn=t.UnboundTypeError=tn(Error,\"UnboundTypeError\"),D.push({func:function(){Cn()}});var Tn,Sn={a:function(n,r,e,t){V(\"Assertion failed: \"+m(n)+\", at: \"+[r?m(r):\"unknown filename\",e,t?m(t):\"unknown function\"])},k:function(n,r,e,t,o){var i=J(e);cn(n,{name:r=G(r),fromWireType:function(n){return!!n},toWireType:function(n,r){return r?t:o},argPackAdvance:8,readValueFromPointer:function(n){var t;if(1===e)t=w;else if(2===e)t=_;else{if(4!==e)throw new TypeError(\"Unknown boolean type size: \"+r);t=T}return this.fromWireType(t[n>>i])},destructorFunction:null})},j:function(n,r){cn(n,{name:r=G(r),fromWireType:function(n){var r=sn[n].value;return dn(n),r},toWireType:function(n,r){return pn(r)},argPackAdvance:8,readValueFromPointer:hn,destructorFunction:null})},h:function(n,r,e){var t=J(e);cn(n,{name:r=G(r),fromWireType:function(n){return n},toWireType:function(n,r){if(\"number\"!=typeof r&&\"boolean\"!=typeof r)throw new TypeError('Cannot convert \"'+vn(r)+'\" to '+this.name);return r},argPackAdvance:8,readValueFromPointer:yn(r,t),destructorFunction:null})},d:function(n,r,e,i,a,u){var f=function(n,r){for(var e=[],t=0;t<n;t++)e.push(T[(r>>2)+t]);return e}(r,e);n=G(n),a=function(n,r){var e=-1!=(n=G(n)).indexOf(\"j\")?function(n,r){n.indexOf(\"j\")>=0||V(\"Assertion failed: getDynCaller should only be called with i64 sigs\");var e=[];return function(){e.length=arguments.length;for(var t=0;t<arguments.length;t++)e[t]=arguments[t];return gn(n,r,e)}}(n,r):U.get(r);return\"function\"!=typeof e&&an(\"unknown function pointer with signature \"+n+\": \"+r),e}(i,a),function(n,r,e){t.hasOwnProperty(n)?((void 0===e||void 0!==t[n].overloadTable&&void 0!==t[n].overloadTable[e])&&an(\"Cannot register public name '\"+n+\"' twice\"),function(n,r,e){if(void 0===n[r].overloadTable){var t=n[r];n[r]=function(){return n[r].overloadTable.hasOwnProperty(arguments.length)||an(\"Function '\"+e+\"' called with an invalid number of arguments (\"+arguments.length+\") - expects one of (\"+n[r].overloadTable+\")!\"),n[r].overloadTable[arguments.length].apply(this,arguments)},n[r].overloadTable=[],n[r].overloadTable[t.argCount]=t}}(t,n,n),t.hasOwnProperty(e)&&an(\"Cannot register multiple overloads of a function with the same number of arguments (\"+e+\")!\"),t[n].overloadTable[e]=r):(t[n]=r,void 0!==e&&(t[n].numArguments=e))}(n,(function(){!function(n,r){var e=[],t={};throw r.forEach((function n(r){t[r]||X[r]||(nn[r]?nn[r].forEach(n):(e.push(r),t[r]=!0))})),new wn(n+\": \"+e.map(bn).join([\", \"]))}(\"Cannot call \"+n+\" due to unbound types\",f)}),r-1),function(e,i,f){function c(i){var f=function(e){var i=[e[0],null].concat(e.slice(1));return function(n,r,e){t.hasOwnProperty(n)||fn(\"Replacing nonexistant public symbol\"),void 0!==t[n].overloadTable&&void 0!==e?t[n].overloadTable[e]=r:(t[n]=r,t[n].argCount=e)}(n,function(n,r,e,t,i){var a=r.length;a<2&&an(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");for(var u=null!==r[1]&&null!==e,f=!1,c=1;c<r.length;++c)if(null!==r[c]&&void 0===r[c].destructorFunction){f=!0;break}var l=\"void\"!==r[0].name,s=\"\",d=\"\";for(c=0;c<a-2;++c)s+=(0!==c?\", \":\"\")+\"arg\"+c,d+=(0!==c?\", \":\"\")+\"arg\"+c+\"Wired\";var p=\"return function \"+rn(n)+\"(\"+s+\") {\\nif (arguments.length !== \"+(a-2)+\") {\\nthrowBindingError('function \"+n+\" called with ' + arguments.length + ' arguments, expected \"+(a-2)+\" args!');\\n}\\n\";f&&(p+=\"var destructors = [];\\n\");var h=f?\"destructors\":\"null\",v=[\"throwBindingError\",\"invoker\",\"fn\",\"runDestructors\",\"retType\",\"classParam\"],y=[an,t,i,mn,r[0],r[1]];for(u&&(p+=\"var thisWired = classParam.toWireType(\"+h+\", this);\\n\"),c=0;c<a-2;++c)p+=\"var arg\"+c+\"Wired = argType\"+c+\".toWireType(\"+h+\", arg\"+c+\"); // \"+r[c+2].name+\"\\n\",v.push(\"argType\"+c),y.push(r[c+2]);if(u&&(d=\"thisWired\"+(d.length>0?\", \":\"\")+d),p+=(l?\"var rv = \":\"\")+\"invoker(fn\"+(d.length>0?\", \":\"\")+d+\");\\n\",f)p+=\"runDestructors(destructors);\\n\";else for(c=u?1:2;c<r.length;++c){var m=1===c?\"thisWired\":\"arg\"+(c-2)+\"Wired\";null!==r[c].destructorFunction&&(p+=m+\"_dtor(\"+m+\"); // \"+r[c].name+\"\\n\",v.push(m+\"_dtor\"),y.push(r[c].destructorFunction))}return l&&(p+=\"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\"),p+=\"}\\n\",v.push(p),function(n,r){if(!(n instanceof Function))throw new TypeError(\"new_ called with constructor type \"+o(n)+\" which is not a function\");var e=en(n.name||\"unknownFunctionName\",(function(){}));e.prototype=n.prototype;var t=new e,i=n.apply(t,r);return i instanceof Object?i:t}(Function,v).apply(null,y)}(n,i,null,a,u),r-1),[]}(i);f.length!==e.length&&fn(\"Mismatched type converter count\");for(var c=0;c<e.length;++c)cn(e[c],f[c])}e.forEach((function(n){nn[n]=i}));var l=new Array(i.length),s=[],d=0;i.forEach((function(n,r){X.hasOwnProperty(n)?l[r]=X[n]:(s.push(n),K.hasOwnProperty(n)||(K[n]=[]),K[n].push((function(){l[r]=X[n],++d===s.length&&c(l)})))})),0===s.length&&c(l)}([],f)},c:function(n,r,e,t,o){r=G(r),-1===o&&(o=4294967295);var i=J(e),a=function(n){return n};if(0===t){var u=32-8*e;a=function(n){return n<<u>>>u}}var f=-1!=r.indexOf(\"unsigned\");cn(n,{name:r,fromWireType:a,toWireType:function(n,e){if(\"number\"!=typeof e&&\"boolean\"!=typeof e)throw new TypeError('Cannot convert \"'+vn(e)+'\" to '+this.name);if(e<t||e>o)throw new TypeError('Passing a number \"'+vn(e)+'\" from JS side to C/C++ side to an argument of type \"'+r+'\", which is outside the valid range ['+t+\", \"+o+\"]!\");return f?e>>>0:0|e},argPackAdvance:8,readValueFromPointer:_n(r,i,0!==t),destructorFunction:null})},b:function(n,r,e){var t=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][r];function o(n){var r=S,e=r[n>>=2],o=r[n+1];return new t(g,o,e)}cn(n,{name:e=G(e),fromWireType:o,argPackAdvance:8,readValueFromPointer:o},{ignoreDuplicateRegistrations:!0})},f:function(n,r){var e=\"std::string\"===(r=G(r));cn(n,{name:r,fromWireType:function(n){var r,t=S[n>>2];if(e)for(var o=n+4,i=0;i<=t;++i){var a=n+4+i;if(i==t||0==b[a]){var u=m(o,a-o);void 0===r?r=u:(r+=String.fromCharCode(0),r+=u),o=a+1}}else{var f=new Array(t);for(i=0;i<t;++i)f[i]=String.fromCharCode(b[n+4+i]);r=f.join(\"\")}return En(n),r},toWireType:function(n,r){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var t=\"string\"==typeof r;t||r instanceof Uint8Array||r instanceof Uint8ClampedArray||r instanceof Int8Array||an(\"Cannot pass non-string to std::string\");var o=(e&&t?function(){return function(n){for(var r=0,e=0;e<n.length;++e){var t=n.charCodeAt(e);t>=55296&&t<=57343&&(t=65536+((1023&t)<<10)|1023&n.charCodeAt(++e)),t<=127?++r:r+=t<=2047?2:t<=65535?3:4}return r}(r)}:function(){return r.length})(),i=Rn(4+o+1);if(S[i>>2]=o,e&&t)!function(n,r,e,t){if(!(t>0))return 0;for(var o=e+t-1,i=0;i<n.length;++i){var a=n.charCodeAt(i);if(a>=55296&&a<=57343&&(a=65536+((1023&a)<<10)|1023&n.charCodeAt(++i)),a<=127){if(e>=o)break;r[e++]=a}else if(a<=2047){if(e+1>=o)break;r[e++]=192|a>>6,r[e++]=128|63&a}else if(a<=65535){if(e+2>=o)break;r[e++]=224|a>>12,r[e++]=128|a>>6&63,r[e++]=128|63&a}else{if(e+3>=o)break;r[e++]=240|a>>18,r[e++]=128|a>>12&63,r[e++]=128|a>>6&63,r[e++]=128|63&a}}r[e]=0}(r,b,i+4,o+1);else if(t)for(var a=0;a<o;++a){var u=r.charCodeAt(a);u>255&&(En(i),an(\"String has UTF-16 code units that do not fit in 8 bits\")),b[i+4+a]=u}else for(a=0;a<o;++a)b[i+4+a]=r[a];return null!==n&&n.push(En,i),i},argPackAdvance:8,readValueFromPointer:hn,destructorFunction:function(n){En(n)}})},e:function(n,r,e){var t,o,i,a,u;e=G(e),2===r?(t=P,o=k,a=W,i=function(){return A},u=1):4===r&&(t=I,o=F,a=x,i=function(){return S},u=2),cn(n,{name:e,fromWireType:function(n){for(var e,o=S[n>>2],a=i(),f=n+4,c=0;c<=o;++c){var l=n+4+c*r;if(c==o||0==a[l>>u]){var s=t(f,l-f);void 0===e?e=s:(e+=String.fromCharCode(0),e+=s),f=l+r}}return En(n),e},toWireType:function(n,t){\"string\"!=typeof t&&an(\"Cannot pass non-string to C++ string type \"+e);var i=a(t),f=Rn(4+i+r);return S[f>>2]=i>>u,o(t,f+4,i+r),null!==n&&n.push(En,f),f},argPackAdvance:8,readValueFromPointer:hn,destructorFunction:function(n){En(n)}})},l:function(n,r){cn(n,{isVoid:!0,name:r=G(r),argPackAdvance:0,fromWireType:function(){},toWireType:function(n,r){}})},m:dn,n:function(n){n>4&&(sn[n].refcount+=1)},i:function(n,r){var e,t;return\"_emval_take_value\",void 0===(t=X[e=n])&&an(\"_emval_take_value has unknown type \"+bn(e)),pn((n=t).readValueFromPointer(r))},g:function(){V()},o:function(n,r,e){b.copyWithin(n,r,r+e)},p:function(n){n>>>=0;var r=b.length,e=2147483648;if(n>e)return!1;for(var t,o=1;o<=4;o*=2){var i=r*(1+.2/o);if(i=Math.min(i,n+100663296),An(Math.min(e,((t=Math.max(16777216,n,i))%65536>0&&(t+=65536-t%65536),t))))return!0}return!1}},Cn=(function(){var n={a:Sn};function r(n,r){var e=n.exports;t.asm=e,O((p=t.asm.q).buffer),U=t.asm.r,function(n){if(N--,t.monitorRunDependencies&&t.monitorRunDependencies(N),0==N&&(null!==L&&(clearInterval(L),L=null),H)){var r=H;H=null,r()}}()}function o(n){r(n.instance)}function i(r){return(s||\"function\"!=typeof fetch?Promise.resolve().then((function(){return Q(q)})):fetch(q,{credentials:\"same-origin\"}).then((function(n){if(!n.ok)throw\"failed to load wasm binary file at '\"+q+\"'\";return n.arrayBuffer()})).catch((function(){return Q(q)}))).then((function(r){return WebAssembly.instantiate(r,n)})).then(r,(function(n){h(\"failed to asynchronously prepare wasm: \"+n),V(n)}))}if(N++,t.monitorRunDependencies&&t.monitorRunDependencies(N),t.instantiateWasm)try{return t.instantiateWasm(n,r)}catch(n){return h(\"Module.instantiateWasm callback failed with error: \"+n),!1}(s||\"function\"!=typeof WebAssembly.instantiateStreaming||z(q)||\"function\"!=typeof fetch?i(o):fetch(q,{credentials:\"same-origin\"}).then((function(r){return WebAssembly.instantiateStreaming(r,n).then(o,(function(n){return h(\"wasm streaming compile failed: \"+n),h(\"falling back to ArrayBuffer instantiation\"),i(o)}))}))).catch(e)}(),t.___wasm_call_ctors=function(){return(Cn=t.___wasm_call_ctors=t.asm.s).apply(null,arguments)}),En=(t._main=function(){return(t._main=t.asm.t).apply(null,arguments)},t._free=function(){return(En=t._free=t.asm.u).apply(null,arguments)}),Rn=t._malloc=function(){return(Rn=t._malloc=t.asm.v).apply(null,arguments)},Pn=t.___getTypeName=function(){return(Pn=t.___getTypeName=t.asm.w).apply(null,arguments)};function kn(n){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+n+\")\",this.status=n}function Wn(n){function e(){Tn||(Tn=!0,t.calledRun=!0,v||(Z(D),Z(M),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),In&&function(n){var r,e=t._main;try{r=e(0,0),d&&0===r||(d||(t.onExit&&t.onExit(r),v=!0),c(r,new kn(r)))}catch(n){if(n instanceof kn)return;if(\"unwind\"==n)return void(d=!0);var i=n;n&&\"object\"===o(n)&&n.stack&&(i=[n,n.stack]),h(\"exception thrown: \"+i),c(1,n)}}(),function(){if(t.postRun)for(\"function\"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;)n=t.postRun.shift(),B.unshift(n);var n;Z(B)}()))}n=n||f,N>0||(function(){if(t.preRun)for(\"function\"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)n=t.preRun.shift(),j.unshift(n);var n;Z(j)}(),N>0||(t.setStatus?(t.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){t.setStatus(\"\")}),1),e()}),1)):e()))}if(t.___embind_register_native_and_builtin_types=function(){return(t.___embind_register_native_and_builtin_types=t.asm.x).apply(null,arguments)},H=function n(){Tn||Wn(),Tn||(H=n)},t.run=Wn,t.preInit)for(\"function\"==typeof t.preInit&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();var In=!0;return t.noInitialRun&&(In=!1),d=!0,Wn(),n.ready});\"object\"===o(r)&&\"object\"===o(n)?n.exports=a:void 0===(t=function(){return a}.apply(r,[]))||(n.exports=t)},498:(n,r,e)=>{\"use strict\";e.r(r),e.d(r,{ConverterType:()=>c,create:()=>l});var t=e(17),o=e.n(t);function i(n,r){for(var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,t=null===e?new Float32Array(n):e,o=0;o<n;o++)t[o]=r[o];return t}function a(n,r){for(var e=0;e<r.length;e++){var t=r[e];t.enumerable=t.enumerable||!1,t.configurable=!0,\"value\"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}var u=1008e3,f=function(){function n(r,e,t,o,i){!function(n,r){if(!(n instanceof r))throw new TypeError(\"Cannot call a class as a function\")}(this,n),this.module=r,this.converterType=e,this.nChannels=t,this.inputSampleRate=o,this.outputSampleRate=i,this.ratio=i/o,this.isDestroyed=!1,r.init(t,e,o,i),this.sourceArray=r.sourceArray(u),this.targetArray=r.targetArray(u)}var r,e;return r=n,(e=[{key:\"simple\",value:function(n){return this._resample(this.module.simple,n)}},{key:\"full\",value:function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this._resample(this.module.full,n,r)}},{key:\"destroy\",value:function(){!0===this.isDestroyed?console.warn(\"destroy() has already been called on this instance\"):(this.module.destroy(),this.isDestroyed=!0)}},{key:\"_chunkAndResample\",value:function(n){for(var r=0,e=[],t=function(n,r,e){for(var t=0,o=[],i=0;i<n.length;i+=r){var a=Math.min(r,n.length-t),u=new e(n.buffer,t*n.BYTES_PER_ELEMENT,a);t+=r,o.push(u)}return o}(n,this.inputSampleRate/10*this.nChannels,Float32Array),o=0;o<t.length;o++){var i=this._resample(this.module.full,t[o]);r+=i.length,e.push(i)}for(var a=new Float32Array(r),u=0,f=0;f<e.length;f++)for(var c=0;c<e[f].length;c++)a[u++]=e[f][c];return a}},{key:\"_resample\",value:function(n,r){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(this.inputSampleRate===this.outputSampleRate)return r;if(null!==e&&e.length<this.ratio*r.length)throw\"dataOut must be at least ceil(srcRatio * dataIn.length) samples long\";var t=Math.ceil(r.length*this.ratio);if(t>u)return this._chunkAndResample(r);this.sourceArray.set(r);var o=n(r.length,this.nChannels,this.converterType,this.inputSampleRate,this.outputSampleRate);return i(o*this.nChannels,this.targetArray,e)}}])&&a(r.prototype,e),n}(),c={SRC_SINC_BEST_QUALITY:0,SRC_SINC_MEDIUM_QUALITY:1,SRC_SINC_FASTEST:2,SRC_ZERO_ORDER_HOLD:3,SRC_LINEAR:4};function l(n,r,e){var t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=void 0===t.converterType?c.SRC_SINC_FASTEST:t.converterType,a=t.wasmPath||\"/libsamplerate.wasm\";if(void 0===n)throw\"nChannels is undefined\";if(void 0===r)throw\"inputSampleRate is undefined\";if(void 0===e)throw\"outputSampleRate is undefined\";if(n<1||n>128)throw\"invalid nChannels submitted\";if(r<1||r>192e3)throw\"invalid inputSampleRate\";if(e<1||e>192e3)throw\"invalid outputSampleRate\";if(i<c.SRC_SINC_BEST_QUALITY||i>c.SRC_LINEAR)throw\"invalid converterType\";var u={locateFile:function(n){return a}};return new Promise((function(t,a){o()(u).then((function(o){var a=new f(o,i,n,r,e);t(a)})).catch((function(n){a(n)}))}))}}},r={};function e(t){if(r[t])return r[t].exports;var o=r[t]={id:t,loaded:!1,exports:{}};return n[t](o,o.exports,e),o.loaded=!0,o.exports}return e.n=n=>{var r=n&&n.__esModule?()=>n.default:()=>n;return e.d(r,{a:r}),r},e.d=(n,r)=>{for(var t in r)e.o(r,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:r[t]})},e.o=(n,r)=>Object.prototype.hasOwnProperty.call(n,r),e.r=n=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},e.nmd=n=>(n.paths=[],n.children||(n.children=[]),n),e(498)})()}));\n\n//# sourceURL=webpack://FeederNode/./node_modules/@alexanderolsen/libsamplerate-js/dist/libsamplerate.js?");

/***/ }),

/***/ "./src/abstract-backend.js":
/*!*********************************!*\
  !*** ./src/abstract-backend.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BackendState\": () => /* binding */ BackendState,\n/* harmony export */   \"AbstractBackend\": () => /* binding */ AbstractBackend\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar BackendState = {\n  UNINITIALIZED: 1,\n  READY: 2,\n  PLAYING: 3,\n  STARVED: 4\n};\nObject.freeze(BackendState);\n/** Abstract class representing an Audio Backend */\n\nvar AbstractBackend = /*#__PURE__*/function () {\n  function AbstractBackend() {\n    _classCallCheck(this, AbstractBackend);\n  }\n\n  _createClass(AbstractBackend, [{\n    key: \"feed\",\n\n    /**\n     * Cues audio data for propagation to the next AudioNode in the graph\n     *\n     * @param { Float32Array } float32Array Mono or interleaved audio data\n     */\n    value: function feed(float32Array) {\n      throw 'feed() must be implemented';\n    }\n    /**\n     * Connect to the given destination. Destination should be an AudioNode.\n     *\n     * @param { AudioNode } destination The AudioNode to which audio is propagated\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(destination) {\n      throw 'connect() must be implemented';\n    }\n    /** Disconnect from the currently-connected destination. */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      throw 'disconnect() must be implemented';\n    }\n    /**\n     * Sets a MessageChannel Port to receive processed data from. Should be, but doesn't *have* to be\n     * implemented by subclasses.\n     * \n     * @param { MessagePort } port port1 or port2 from a MessageChannel\n     */\n\n  }, {\n    key: \"setPort\",\n    value: function setPort(port) {}\n    /**\n     * Called whenever the state changes (playing, silent, etc.) Override me.\n     *\n     * @param {BackendState} state One of BackendState\n     */\n\n  }, {\n    key: \"onStateChange\",\n    value: function onStateChange(state) {}\n  }]);\n\n  return AbstractBackend;\n}();\n\n//# sourceURL=webpack://FeederNode/./src/abstract-backend.js?");

/***/ }),

/***/ "./src/abstract-processor.js":
/*!***********************************!*\
  !*** ./src/abstract-processor.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ AbstractProcessor\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/** Abstract class for Processors which process audio data before handing to AudioNode chain */\nvar AbstractProcessor = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   * \n   * @param { Number } inputSampleRate  The sample rate of incoming data\n   * @param { Number } outputSampleRate The sampleRate which processed data should be\n   */\n  function AbstractProcessor(inputSampleRate, outputSampleRate) {\n    _classCallCheck(this, AbstractProcessor);\n\n    this.inputSampleRate = inputSampleRate;\n    this.outputSampleRate = outputSampleRate;\n  }\n  /**\n   * Operate on interleavedFloat32Data. Once operations are complete, return data with onProcessed()\n   *\n   * @param { Float32Array } interleavedFloat32Data Mono or interleaved audio data\n   */\n\n\n  _createClass(AbstractProcessor, [{\n    key: \"processBatch\",\n    value: function processBatch(interleavedFloat32Data) {\n      throw new Error('processBatch must be overridden!');\n    }\n    /**\n     * Called once data has been operated on by processBatch(). Override me.\n     * \n     * @param { Float32Array } interleavedFloat32Data Mono or interleaved audio data\n     */\n\n  }, {\n    key: \"onProcessed\",\n    value: function onProcessed(interleavedFloat32Data) {\n      throw new Error('onProcessed must be overridden!');\n    }\n    /**\n     * Sets a MessageChannel Port to send processed data thru. Should be, but doesn't *have* to be\n     * implemented by subclasses.\n     * \n     * @param { MessagePort } port port1 or port2 from a MessageChannel\n     */\n\n  }, {\n    key: \"setPort\",\n    value: function setPort(port) {}\n  }]);\n\n  return AbstractProcessor;\n}();\n\n\n\n//# sourceURL=webpack://FeederNode/./src/abstract-processor.js?");

/***/ }),

/***/ "./src/audio-worklet-backend.js":
/*!**************************************!*\
  !*** ./src/audio-worklet-backend.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ createAudioWorklet\n/* harmony export */ });\n/* harmony import */ var _abstract_backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-backend */ \"./src/abstract-backend.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * Loads the AudioWorkletProcessor, initializes it, then resolves with a new instance of AudioWorkletBackend\n * \n * @param { AudioContext } context         The parent AudioContext\n * @param { Number }       nChannels       The number of input and output channels\n * @param { Number }       bufferLength    The length of the RingBuffer. See ring-buffer.js for more\n * @param { Number }       bufferThreshold The minimum number of sample which must be buffered before\n *                                         audio begins propagating to the next AudioNode in the graph\n * @param { String }       pathToWorklet   The location of the AudioWorklet file. Default is \n *                                         '/audio-feeder.worklet.js'\n */\n\nfunction createAudioWorklet(context, nChannels, bufferLength, bufferThreshold, pathToWorklet) {\n  var _nChannels = nChannels; // define this here so that window is accessible\n\n  var WorkletNode = /*#__PURE__*/function (_AudioWorkletNode) {\n    _inherits(WorkletNode, _AudioWorkletNode);\n\n    var _super = _createSuper(WorkletNode);\n\n    function WorkletNode(context) {\n      _classCallCheck(this, WorkletNode);\n\n      return _super.call(this, context, 'FeederNode', {\n        numberOfInputs: 0,\n        numberOfOutputs: 1,\n        outputChannelCount: [_nChannels]\n      });\n    }\n\n    return WorkletNode;\n  }( /*#__PURE__*/_wrapNativeSuper(AudioWorkletNode));\n\n  return new Promise(function (resolve, reject) {\n    context.audioWorklet.addModule(pathToWorklet).then(function () {\n      var workletNode = new WorkletNode(context);\n      workletNode.port.postMessage({\n        command: 'init',\n        nChannels: nChannels,\n        bufferLength: bufferLength,\n        bufferThreshold: bufferThreshold\n      });\n      var backend = new AudioWorkletBackend(nChannels, bufferLength, workletNode);\n      resolve(backend);\n    });\n  });\n}\n/** Audio backend which plays + processes audio on the Audio Thread */\n\nvar AudioWorkletBackend = /*#__PURE__*/function (_AbstractBackend) {\n  _inherits(AudioWorkletBackend, _AbstractBackend);\n\n  var _super2 = _createSuper(AudioWorkletBackend);\n\n  /**\n   * Constructor.\n   * \n   * @param { Number }       nChannels    The number of input and output channels\n   * @param { Number }       bufferLength The length of the RingBuffer. See ring-buffer.js for more\n   * @param { AudioNode }    audioNode    The initialized AudioWorkletProcessor\n   */\n  function AudioWorkletBackend(nChannels, bufferLength, audioNode) {\n    var _this;\n\n    _classCallCheck(this, AudioWorkletBackend);\n\n    _this = _super2.call(this);\n    _this.nChannels = nChannels;\n    _this.bufferLength = bufferLength;\n    _this.audioNode = audioNode;\n    _this.batchSize = 128;\n    _this.state = _abstract_backend__WEBPACK_IMPORTED_MODULE_0__.BackendState.READY;\n    audioNode.port.onmessage = _this._onMessage.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Passes data to the AudioWorkletProcessor for playback\n   */\n\n\n  _createClass(AudioWorkletBackend, [{\n    key: \"feed\",\n    value: function feed(float32Array) {\n      if (this.state === _abstract_backend__WEBPACK_IMPORTED_MODULE_0__.BackendState.UNINITIALIZED) {\n        console.warn('tried to call feed() on uninitialized backend');\n      } else {\n        this.audioNode.port.postMessage({\n          command: 'feed',\n          data: float32Array\n        }, [float32Array.buffer]);\n      }\n    }\n    /**\n     * Passes the port the audioNode to receive data directly from resamplers.\n     *\n     * @param { MessagePort } port port1 or port2 from a MessageChannel\n     */\n\n  }, {\n    key: \"setPort\",\n    value: function setPort(port) {\n      this.audioNode.port.postMessage({\n        command: 'connect'\n      }, [port]);\n    }\n    /**\n     * Loads + intializes the AudioWorkletProcessor, then connects it to the provided destination AudioNode\n     * \n     * @param {AudioNode} destination The node to which FeederNode will connect\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(destination) {\n      this.audioNode.connect(destination);\n    }\n    /**\n     * Disconnect from the connected AudioNode\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.audioNode.disconnect();\n    }\n    /**\n     * Called whenever a message from the AudioWorkletProcessor is received\n     * \n     * @param {Event} e https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\n     */\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(e) {\n      if (e.data.command === 'bufferLengthChange') {\n        this.bufferLength = e.data.bufferLength;\n      } else if (e.data.command === 'stateChange') {\n        this.onStateChange(e.data.state);\n      } else {\n        throw \"command \".concat(e.data.command, \" unrecognized\");\n      }\n    }\n  }]);\n\n  return AudioWorkletBackend;\n}(_abstract_backend__WEBPACK_IMPORTED_MODULE_0__.AbstractBackend);\n\n//# sourceURL=webpack://FeederNode/./src/audio-worklet-backend.js?");

/***/ }),

/***/ "./src/feeder-node-create.js":
/*!***********************************!*\
  !*** ./src/feeder-node-create.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ create\n/* harmony export */ });\n/* harmony import */ var _script_processor_backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./script-processor-backend */ \"./src/script-processor-backend.js\");\n/* harmony import */ var _main_thread_resampler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main-thread-resampler */ \"./src/main-thread-resampler.js\");\n/* harmony import */ var _audio_worklet_backend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audio-worklet-backend */ \"./src/audio-worklet-backend.js\");\n/* harmony import */ var _worker_resampler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-resampler */ \"./src/worker-resampler.js\");\n/* harmony import */ var _feeder_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./feeder-node */ \"./src/feeder-node.js\");\n/* harmony import */ var _alexanderolsen_libsamplerate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @alexanderolsen/libsamplerate-js */ \"./node_modules/@alexanderolsen/libsamplerate-js/dist/libsamplerate.js\");\n/* harmony import */ var _alexanderolsen_libsamplerate_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_alexanderolsen_libsamplerate_js__WEBPACK_IMPORTED_MODULE_5__);\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n // The batch sizes which ScriptProcessorNode supports. AudioWorklet only support 128.\n\nvar VALID_BATCH_SIZES = [128, 256, 512, 1024, 2048, 4096, 8192, 16384];\n/**\n * Creates a new instance of FeederNode\n *\n * `options` is an object which supports the follow members: \n * {\n *     batchSize:           { Number } default 512. Stuck at 128 for `AudioWorklet`s\n *     bufferThreshold:     { Number } default 4096. Number of samples to buffer before propagating to destination\n *     bufferLength:        { Number } default 192000. Length of RingBuffer. See ring-buffer.js for more\n *     resampConverterType: { Number } default ConverterType.SRC_SINC_FASTEST. See http://www.mega-nerd.com/SRC/api_misc.html#Converters\n *     inputSampleRate:     { Number } default context.sampleRate\n *     pathToWorklet:       { String } default '/feeder-node.processor.js'. See README for more\n *     pathToWorker:        { String } default '/feeder-node.worker.js'. See README for more\n *     pathToWasm:          { String } default '/feeder-node.wasm.js'. See README for more\n * }\n * \n * @param  { AudioContext } context   The parent audio context.\n * @param  { Number }       nChannels The number of input and output channels.\n * @param  { Object }       options   See above\n * @return { Promise }                Promise which resolves with a FeederNode instance or rejects with error message.\n */\n\nfunction create(_x, _x2) {\n  return _create.apply(this, arguments);\n}\n/**\n * Validate input used to create an FeederNode\n *\n * @param { Number } nChannels       The number of input and output channels\n * @param { Number } batchSize       Must be one of VALID_BATCH_SIZES. \n * @param { Number } bufferThreshold Number of samples which must be buffered before playback begins\n * @param { Number } bufferLength    RingBuffer length in samples (per channel). See ring-buffer.js for more.\n * @param { Number } converterType   libsamplerate-js ConverterType. See libsamplerate for more.\n * @param { Number } inputSampleRate Sample rate of input data\n */\n\nfunction _create() {\n  _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(context, nChannels) {\n    var options,\n        batchSize,\n        bufferThreshold,\n        bufferLength,\n        converterType,\n        inputSampleRate,\n        outputSampleRate,\n        pathToWorklet,\n        pathToWorker,\n        pathToWasm,\n        backend,\n        resampler,\n        feederNode,\n        _args = arguments;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            batchSize = options.batchSize || (window.AudioWorklet !== undefined ? 128 : 512);\n            bufferThreshold = options.bufferThreshold || 4096;\n            bufferLength = options.bufferLength || 192000;\n            converterType = options.resampConverterType === undefined ? _alexanderolsen_libsamplerate_js__WEBPACK_IMPORTED_MODULE_5__.ConverterType.SRC_SINC_FASTEST : options.resampConverterType;\n            inputSampleRate = options.inputSampleRate || context.sampleRate;\n            outputSampleRate = context.sampleRate;\n            pathToWorklet = options.pathToWorklet || '/feeder-node.processor.js';\n            pathToWorker = options.pathToWorker || '/feeder-node.worker.js';\n            pathToWasm = options.pathToWasm || '/libsamplerate.wasm';\n            validate(nChannels, batchSize, bufferThreshold, bufferLength, converterType, inputSampleRate); // **BACKEND MUST BE CREATED FIRST.** After `createSampler`'s async initialization,  touch events in Safari\n            // are no longer active and therefore `ScriptProcessorNode`s won't initialize correctly\n\n            _context.next = 13;\n            return createBackend(context, nChannels, batchSize, bufferLength, bufferThreshold, pathToWorklet);\n\n          case 13:\n            backend = _context.sent;\n            _context.next = 16;\n            return createResampler(nChannels, inputSampleRate, outputSampleRate, converterType, pathToWorker, pathToWasm);\n\n          case 16:\n            resampler = _context.sent;\n            feederNode = new _feeder_node__WEBPACK_IMPORTED_MODULE_4__.default(resampler, backend);\n            return _context.abrupt(\"return\", feederNode);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _create.apply(this, arguments);\n}\n\nfunction validate(nChannels, batchSize, bufferThreshold, bufferLength, converterType, inputSampleRate) {\n  if (nChannels === undefined) throw 'nChannels is undefined';\n  if (nChannels < 1 || nChannels > 2) throw \"invalid nChannels \".concat(nChannels);\n  if (!VALID_BATCH_SIZES.includes(batchSize)) throw \"invalid batchSize \".concat(batchSize);\n  if (bufferLength < 16384) throw 'buffer length must be greater than 16384';\n  if (bufferThreshold < 0) throw 'bufferThreshold cannot be less than 0';\n  if (bufferThreshold > bufferLength) throw 'bufferThreshold cannot be greater than bufferLength';\n  if (converterType < 0 || converterType > 4) throw \"invalid converterType \".concat(converterType);\n  if (inputSampleRate < 1 || inputSampleRate > 192000) throw \"invalid inputSampleRate \".concat(inputSampleRate);\n}\n/**\n * Creates a resampler to be used by FeederNode. All resamplers extends AbstractProcessor. \n * If WebAssembly is supported in current browser, loads libsamplerate-js and run it in a \n * Web Worker. If not, resamples audio data on the main thread using resampler.js linear interpolation.\n * \n * @param  { Number } nChannels        The number of input and output channels\n * @param  { Number } inputSampleRate  Sample rate of input data\n * @param  { Number } outputSampleRate Sample rate of output data. Probably came from AudioContext.sampleRate\n * @param  { Number } converterType    libsamplerate-js ConverterType. See libsamplerate for more.\n * @return { AbstractProcessor }       The resampler to use\n */\n\n\nfunction createResampler(_x3, _x4, _x5, _x6, _x7, _x8) {\n  return _createResampler.apply(this, arguments);\n}\n/**\n * Creates a Backend to be used by FeederNode. Backends extend AbstractBackend. If AudioWorklet\n * is supported, creates an AudioWorkletBackend. Otherwise, plays audio using ScriptProcessorNode.\n * \n * @param  { AudioContext } context         Audio context in which this node participates\n * @param  { Number }       nChannels       The number of input and output channels\n * @param  { Number }       batchSize       Must be one of VALID_BATCH_SIZES.\n * @param  { Number }       bufferThreshold Number of samples which must be buffered before playback begins\n * @param  { Number }       bufferLength    RingBuffer length in samples (per channel). See ring-buffer.js for more.\n * @param  { Number }       converterType   libsamplerate-js ConverterType. See libsamplerate for more.\n * @param  { String }       pathToWorklet   Path from server root to feeder-node.worklet.js\n * @return { AbstractBackend }              The backend to perform audio propagation with.\n */\n\n\nfunction _createResampler() {\n  _createResampler = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(nChannels, inputSampleRate, outputSampleRate, converterType, pathToWorker, pathToWasm) {\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(window.WebAssembly !== undefined)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 3;\n            return (0,_worker_resampler__WEBPACK_IMPORTED_MODULE_3__.default)(nChannels, inputSampleRate, outputSampleRate, converterType, pathToWorker, pathToWasm);\n\n          case 3:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 6:\n            return _context2.abrupt(\"return\", new _main_thread_resampler__WEBPACK_IMPORTED_MODULE_1__.default(nChannels, inputSampleRate, outputSampleRate));\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _createResampler.apply(this, arguments);\n}\n\nfunction createBackend(_x9, _x10, _x11, _x12, _x13, _x14) {\n  return _createBackend.apply(this, arguments);\n}\n\nfunction _createBackend() {\n  _createBackend = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(context, nChannels, batchSize, bufferLength, bufferThreshold, pathToWorklet) {\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(window.AudioWorklet !== undefined)) {\n              _context3.next = 6;\n              break;\n            }\n\n            _context3.next = 3;\n            return (0,_audio_worklet_backend__WEBPACK_IMPORTED_MODULE_2__.default)(context, nChannels, bufferLength, bufferThreshold, pathToWorklet);\n\n          case 3:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 6:\n            return _context3.abrupt(\"return\", new _script_processor_backend__WEBPACK_IMPORTED_MODULE_0__.default(context, nChannels, batchSize, bufferLength, bufferThreshold));\n\n          case 7:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _createBackend.apply(this, arguments);\n}\n\n//# sourceURL=webpack://FeederNode/./src/feeder-node-create.js?");

/***/ }),

/***/ "./src/feeder-node.js":
/*!****************************!*\
  !*** ./src/feeder-node.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ FeederNode\n/* harmony export */ });\n/* harmony import */ var _abstract_backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-backend */ \"./src/abstract-backend.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar FeederNode = /*#__PURE__*/function () {\n  function FeederNode(resampler, backend) {\n    _classCallCheck(this, FeederNode);\n\n    // init MessageChannel if using both async resampler and backend\n    if (resampler.constructor.name === 'WorkerResampler' && backend.constructor.name === 'AudioWorkletBackend') {\n      var channel = new MessageChannel();\n      resampler.setPort(channel.port1);\n      backend.setPort(channel.port2);\n    } // set callbacks\n\n\n    resampler.onProcessed = this._onResampleComplete.bind(this);\n    backend.onStateChange = this._onBackendStateChange.bind(this);\n    this._resampler = resampler;\n    this._backend = backend;\n  }\n  /** getters */\n\n\n  _createClass(FeederNode, [{\n    key: \"connect\",\n\n    /**\n     * Connects FeederNode to the specific output AudioNode\n     *\n     * @param {AudioNode} output The node to connect to\n     */\n    value: function connect(output) {\n      this._backend.connect(output);\n    }\n    /** Disconnects from the currently-connected AudioNode */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this._backend.disconnect();\n    }\n    /**\n     * Feeds raw PCM audio data to the underlying node. Any kind of TypedArray can be submitted - FeederNode\n     * will automatically convert to Float32 and scale to -1 < n < 1.\n     *\n     * @param {TypedArray} data Any TypedArray. Conversion will be done automatically\n     */\n\n  }, {\n    key: \"feed\",\n    value: function feed(data) {\n      var parsedData;\n\n      if (ArrayBuffer.isView(data)) {\n        parsedData = (0,_util__WEBPACK_IMPORTED_MODULE_1__.toFloat32)(data);\n      } else {\n        throw Error(\"FeederNode.feed() must receive an instance of TypedArray. You passed \".concat(data.constructor.name));\n      }\n\n      this._resampler.processBatch(parsedData);\n    }\n    /** Override these for Backend state callbacks */\n\n  }, {\n    key: \"onBackendReady\",\n    value: function onBackendReady() {}\n  }, {\n    key: \"onBackendPlaying\",\n    value: function onBackendPlaying() {}\n  }, {\n    key: \"onBackendStarved\",\n    value: function onBackendStarved() {}\n    /**\n     * Called by this._resampler if a MessageChannel isn't in use to transfer data from the\n     * resampler directly to the backend\n     *\n     * @param {Float32Array} float32Array Mono or interleaved audio data\n     */\n\n  }, {\n    key: \"_onResampleComplete\",\n    value: function _onResampleComplete(float32Array) {\n      this._backend.feed(float32Array);\n    }\n    /**\n     * Called by the back whenever its state changes\n     *\n     * @param { BackendState } state one of [BackendState.READY, BackendState.PLAYING, BackendState.STARVED]\n     */\n\n  }, {\n    key: \"_onBackendStateChange\",\n    value: function _onBackendStateChange(state) {\n      switch (state) {\n        case _abstract_backend__WEBPACK_IMPORTED_MODULE_0__.BackendState.READY:\n          return this.onBackendReady();\n\n        case _abstract_backend__WEBPACK_IMPORTED_MODULE_0__.BackendState.PLAYING:\n          return this.onBackendPlaying();\n\n        case _abstract_backend__WEBPACK_IMPORTED_MODULE_0__.BackendState.STARVED:\n          return this.onBackendStarved();\n\n        default:\n          throw \"unknown state \".concat(state);\n      }\n    }\n  }, {\n    key: \"bufferLength\",\n    get: function get() {\n      return this._backend.bufferLength;\n    }\n  }, {\n    key: \"nChannels\",\n    get: function get() {\n      return this._backend.nChannels;\n    }\n  }, {\n    key: \"batchSize\",\n    get: function get() {\n      return this._backend.batchSize;\n    }\n  }]);\n\n  return FeederNode;\n}();\n\n\n\n//# sourceURL=webpack://FeederNode/./src/feeder-node.js?");

/***/ }),

/***/ "./src/main-thread-resampler.js":
/*!**************************************!*\
  !*** ./src/main-thread-resampler.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ MainThreadResampler\n/* harmony export */ });\n/* harmony import */ var _abstract_processor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-processor */ \"./src/abstract-processor.js\");\n/* harmony import */ var _resampler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resampler */ \"./src/resampler.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/** \n * Class that resamples audio data on the main thread. Since almost all browsers support web workers\n * at this point, this will probably never be used; worker-resampler.js will be used instead\n */\n\nvar MainThreadResampler = /*#__PURE__*/function (_AbstractProcessor) {\n  _inherits(MainThreadResampler, _AbstractProcessor);\n\n  var _super = _createSuper(MainThreadResampler);\n\n  /**\n   * Constructor\n   * \n   * @param { Number } nChannels        The number of input and output channels\n   * @param { Number } inputSampleRate  Sample rate of incoming audio\n   * @param { Number } outputSampleRate Sample rate which outgoing audio must be\n   */\n  function MainThreadResampler(nChannels, inputSampleRate, outputSampleRate) {\n    var _this;\n\n    _classCallCheck(this, MainThreadResampler);\n\n    _this = _super.call(this, inputSampleRate, outputSampleRate);\n    _this.nChannels = nChannels; // channels need to be de-interleaved before processing. store de-interleaved data in this resusable buffer\n\n    _this.inputChannelBuffers = Array.apply(null, Array(nChannels)).map(function (x, i) {\n      return new Float32Array(192000);\n    });\n    _this._resampler = new _resampler__WEBPACK_IMPORTED_MODULE_1__.default(inputSampleRate, outputSampleRate, nChannels);\n    return _this;\n  }\n  /**\n   * Resample the audio data if necessary, then send back via callback\n   *\n   * @param {Float32Array} interleavedFloat32Data the data to be resampled\n   */\n\n\n  _createClass(MainThreadResampler, [{\n    key: \"processBatch\",\n    value: function processBatch(interleavedFloat32Data) {\n      if (this.inputSampleRate === this.outputSampleRate) return this.onProcessed(interleavedFloat32Data);\n      var dataPerChannel = interleavedFloat32Data.length / this.nChannels; // resize input buffers if necessary\n\n      if (dataPerChannel > this.inputChannelBuffers[0].length) {\n        this.inputChannelBuffers = Array.apply(null, Array(this.nChannels)).map(function (x, i) {\n          return new Float32Array(dataPerChannel);\n        });\n      } // resample\n\n\n      (0,_util__WEBPACK_IMPORTED_MODULE_2__.copyInterleavedToChannels)(interleavedFloat32Data, this.inputChannelBuffers);\n      var trimmedBuffers = this.inputChannelBuffers.map(function (float32Array) {\n        return new Float32Array(float32Array.buffer, 0, dataPerChannel);\n      });\n\n      var resampledBuffers = this._resampler.resample(trimmedBuffers);\n\n      var reinterleaved = (0,_util__WEBPACK_IMPORTED_MODULE_2__.writeChannelsToInterleaved)(resampledBuffers);\n      this.onProcessed(reinterleaved);\n    }\n  }]);\n\n  return MainThreadResampler;\n}(_abstract_processor__WEBPACK_IMPORTED_MODULE_0__.default);\n\n\n\n//# sourceURL=webpack://FeederNode/./src/main-thread-resampler.js?");

/***/ }),

/***/ "./src/resampler.js":
/*!**************************!*\
  !*** ./src/resampler.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ LinearResampler\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Performs upsampling via linear interpolation, and downsampling by simply remove extra\n * samples. In most cases, this class should never be used because uses is a fairly naive\n * resampling algorithm. Prefer @alexanderolsen/libresample-js\n *\n * This class is included because it is fast enough to be used on the main thread. \n */\nvar LinearResampler = /*#__PURE__*/function () {\n  function LinearResampler(inputSampleRate, outputSampleRate, nChannels) {\n    _classCallCheck(this, LinearResampler);\n\n    this.inputSampleRate = inputSampleRate;\n    this.outputSampleRate = outputSampleRate;\n    this.nChannels = nChannels;\n    this._resampleFractional = 0;\n    this._resampleLastSampleData = undefined;\n  }\n  /**\n  @param {SampleBuffer} a list of Float32Arrays, one array per channel\n  Taken from https://github.com/brion/audio-feeder/blob/master/src/index.js\n  */\n\n\n  _createClass(LinearResampler, [{\n    key: \"resample\",\n    value: function resample(sampleData) {\n      var rate = this.inputSampleRate,\n          channels = this.nChannels,\n          targetRate = this.outputSampleRate;\n      if (rate == targetRate) return sampleData;\n      var newSamples = []; // Mind that packet boundaries won't always align on\n      // sample boundaries in the resamples output, so maintain\n      // a running rounding fractional offset of the portion of\n      // a sample we'll have to pull from the previous run on\n      // the next one.\n\n      var inputLen = sampleData[0].length,\n          previousFractional = this._resampleFractional,\n          outputLen = inputLen * targetRate / rate + previousFractional,\n          outputSamples = Math.floor(outputLen),\n          remainingFractional = outputLen - outputSamples;\n      var interpolate;\n\n      if (rate < targetRate) {\n        // Input rate is lower than the target rate,\n        // use linear interpolation to minimize \"tinny\" artifacts.\n        interpolate = function interpolate(input, output, previous, adjustment) {\n          var inputSample = function inputSample(i) {\n            if (i < 0) {\n              if (previous && previous.length + i > 0) {\n                // Beware sometimes we have empty bits at start.\n                return previous[previous.length + i];\n              } else {\n                // this probably shouldn't happen\n                // but if it does be safe ;)\n                return input[0];\n              }\n            } else {\n              return input[i];\n            }\n          };\n\n          for (var i = 0; i < output.length; i++) {\n            // Map the output sample to input space,\n            // offset by one to give us room to interpolate.\n            var j = (i + 1 - previousFractional) * rate / targetRate - 1;\n            var a = Math.floor(j);\n            var b = Math.ceil(j);\n            var out;\n\n            if (a == b) {\n              out = inputSample(a);\n            } else {\n              out = inputSample(a) * (b - j) + inputSample(b) * (j - a);\n            }\n\n            output[i] = out;\n          }\n        };\n      } else {\n        // Input rate is higher than the target rate.\n        // For now, discard extra samples.\n        interpolate = function interpolate(input, output, previous) {\n          for (var i = 0; i < output.length; i++) {\n            output[i] = input[i * input.length / output.length | 0];\n          }\n        };\n      }\n\n      for (var channel = 0; channel < channels; channel++) {\n        var inputChannel = channel;\n        var input = sampleData[inputChannel],\n            output = new Float32Array(outputSamples),\n            previous = this._resampleLastSampleData ? this._resampleLastSampleData[inputChannel] : undefined;\n        interpolate(input, output, previous);\n        newSamples.push(output);\n      }\n\n      this._resampleFractional = remainingFractional;\n      this._resampleLastSampleData = sampleData;\n      return newSamples;\n    }\n  }]);\n\n  return LinearResampler;\n}();\n\n\n\n//# sourceURL=webpack://FeederNode/./src/resampler.js?");

/***/ }),

/***/ "./src/script-processor-backend.js":
/*!*****************************************!*\
  !*** ./src/script-processor-backend.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ create\n/* harmony export */ });\nfunction create() {} // import { AbstractBackend, BackendState } from './abstract-backend';\n// import RingBuffer from './ring-buffer';\n// import { writeSilence } from './util';\n// /** Class that manages a ScriptProcessor to playback PCM audio */\n// export default class ScriptProcessorBackend extends AbstractBackend {\n// \t/**\n// \t *\n// \t * @param { AudioContext } context         The parent AudioContext\n// \t * @param { Number }       nChannels       The number of input and output channels\n// \t * @param { Number }       batchSize       The number of samples (per channel) processed per call to\n// \t *                                         _playNext(). Generally, higher values (2048, 4096, 8192...)\n// \t *                                         should be preferred to reduce CPU load\n// \t * @param { Number }       bufferLength    The length of the RingBuffer. See ring-buffer.js for more\n// \t * @param { Number }       bufferThreshold The minimum number of sample which must be buffered before\n// \t *                                         audio begins propagating to the next AudioNode in the graph\n// \t */\n// \tconstructor(context, nChannels, batchSize, bufferLength, bufferThreshold) {\n// \t\tsuper();\n// \t\tthis.batchSize = batchSize;\n// \t\tthis.nChannels = nChannels;\n// \t\tthis.bufferThreshold = bufferThreshold;\n// \t\tthis._processor = context.createScriptProcessor(batchSize, 0, nChannels);\n// \t\tthis._processor.onaudioprocess = this._playNext.bind(this);\n// \t\tthis._buffer = new RingBuffer(bufferLength, nChannels);\n// \t\tthis.state = BackendState.READY;\n// \t}\n// \t/** getter */\n// \tget bufferLength() { return this._buffer.bufferLength; }\n// \t*\n// \t * Appends data to the ends of the ArrayBuffer. If float32Array.length > the current buffer size,\n// \t * buffer will automatically reseize to fit the new chunk\n// \t *\n// \t * @param {Float32Array} data to write to the RingBuffeer\n// \tfeed(float32Array) {\n// \t\tthis._buffer.write(float32Array);\n// \t}\n// \t/**\n// \t * Connects the ScriptProcessorNode to the given destination AudioNode\n// \t * \n// \t * @param {AudioNode} destination The node to which FeederNode will connect\n// \t */\n// \tconnect(destination) {\n// \t\tthis._processor.connect(destination);\n// \t}\n// \t/**\n// \t * Disconnect from the connected AudioNode\n// \t */\n// \tdisconnect() {\n// \t\tthis._processor.disconnect();\n// \t}\n// \t/**\n// \t * Changes state depending on how much data is available to read into AudioNode chain. If\n// \t * WorkletProcess runs out of data, switches to STARVED; once it buffers enough data, switch\n// \t * back to PLAYING\n// \t */\n// \t_updateState() {\n// \t\tlet staleState = this.state;\n// \t\tswitch (this.state) {\n// \t\t\tcase BackendState.UNINITIALIZED:\n// \t\t\t\treturn;\n// \t\t\tcase BackendState.PLAYING:\n// \t\t\t\tif (this._buffer.getNReadableSamples() === 0) this.state = BackendState.STARVED;\n// \t\t\t\tbreak;\n// \t\t\tcase BackendState.READY:\n// \t\t\tcase BackendState.STARVED:\n// \t\t\t\tif (this._buffer.getNReadableSamples() >= this.bufferThreshold) this.state = BackendState.PLAYING;\n// \t\t\t\tbreak;\n// \t\t\tdefault:\n// \t\t}\n// \t\tif (staleState != this.state) this.onStateChange(this.state);\n// \t}\n// \t/**\n// \t * Called whenever the ScriptProcessor wants to consume more audio\n// \t *\n// \t * @param {AudioProcessingEvent} https://developer.mozilla.org/en-US/docs/Web/API/AudioProcessingEvent\n// \t */\n// \t_playNext(audioProcessingEvent) {\n// \t\tthis._updateState();\n// \t\tlet outs = Array.apply(null, Array(this.nChannels)).map((x, i) => { return audioProcessingEvent.outputBuffer.getChannelData(i) });\n// \t\tif (this.state === BackendState.PLAYING) {\n// \t\t\tthis._buffer.readInto(outs, this.batchSize);\n// \t\t} else {\n// \t\t\twriteSilence(outs);\n// \t\t}\n// \t}\n// }\n\n//# sourceURL=webpack://FeederNode/./src/script-processor-backend.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkFileExists\": () => /* binding */ checkFileExists,\n/* harmony export */   \"writeSilence\": () => /* binding */ writeSilence,\n/* harmony export */   \"writeInterleavedToChannels\": () => /* binding */ writeInterleavedToChannels,\n/* harmony export */   \"copyInterleavedToChannels\": () => /* binding */ copyInterleavedToChannels,\n/* harmony export */   \"writeChannelsToInterleaved\": () => /* binding */ writeChannelsToInterleaved,\n/* harmony export */   \"copyChannelsToInterleaved\": () => /* binding */ copyChannelsToInterleaved,\n/* harmony export */   \"toFloat32\": () => /* binding */ toFloat32\n/* harmony export */ });\n/**\n * Checks that the file is present at the URL specified. If not, warns the user.\n * This is an unfortunately method that we need because WebAudio gives a terrible error message. More:\n * https://github.com/WebAudio/web-audio-api/issues/1846\n *\n * @param {String} pathToWorkletProcessor the path to feeder-node.processor.js\n */\nfunction checkFileExists(pathToFile) {\n  return new Promise(function (resolve, reject) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = function () {\n      var doneReadyState = 4;\n\n      if (xhr.readyState === doneReadyState) {\n        if (xhr.status === 404) {\n          console.error(\"Unable to find file at \".concat(pathToFile, \". You can change this url using the FeederNode constructor options arg\"));\n          reject();\n        } else {\n          resolve();\n        }\n      }\n    };\n\n    xhr.open('GET', pathToFile, true);\n    xhr.send();\n  });\n}\n/**\n * Writes 0 at every index in every channel\n * @param {Array} targetChannels An array of TypedArrays\n */\n\nfunction writeSilence(targetChannels) {\n  for (var i = 0; i < targetChannels.length; i++) {\n    var channel = targetChannels[i];\n\n    for (var j = 0; j < channel.length; j++) {\n      channel[j] = 0;\n    }\n  }\n}\n/**\n * Copies data from an interleaved data array to an mxn array of TypedArrays\n * @param  {TypedArray} interleavedData A TypedArray containing interleaved audio data.\n * @param  {Number}     nChannels       The number of channels to write interleavedData to\n * @return {Array}                      A multi-channel representation of the interleaved data\n */\n\nfunction writeInterleavedToChannels(interleavedData, nChannels) {\n  if (!Number.isInteger(nChannels)) throw 'nChannels must be an integer';\n  var dataPerChannel = interleavedData.length / nChannels;\n  var channels = Array.apply(null, Array(nChannels)).map(function (x, i) {\n    return new Float32Array(dataPerChannel);\n  });\n  copyInterleavedToChannels(interleavedData, channels);\n  return channels;\n}\n/**\n * Copies data from an interleaved data array to an mxn array of TypedArrays\n * @param {TypedArray} interleavedData A TypedArray containing interleaved audio data.\n * @param {Array}      targetChannels  An mxn array of m TypedArrays with length n. interleaved data is copied into these arrays\n */\n\nfunction copyInterleavedToChannels(interleavedData, targetChannels) {\n  if (interleavedData.length > targetChannels[0].length * targetChannels.length) throw 'incorrect channel lengths';\n\n  for (var channelNum = 0; channelNum < targetChannels.length; channelNum++) {\n    var dataPos = channelNum;\n\n    for (var channelPos = 0; channelPos < targetChannels[channelNum].length; channelPos++) {\n      targetChannels[channelNum][channelPos] = interleavedData[dataPos];\n      dataPos += targetChannels.length;\n    }\n  }\n}\n/**\n * Writes channel data to a new interleaved array. Basically just wraps copyChannelsToInterleaved\n * @param  {Array}      channels An mxn array containing m TypedArrays with length n\n * @return {TypedArray} an interleaved representation of channels\n */\n\nfunction writeChannelsToInterleaved(channels) {\n  var interleavedLength = channels[0].length * channels.length;\n  var interleaved = new Float32Array(interleavedLength);\n  copyChannelsToInterleaved(channels, interleaved);\n  return interleaved;\n}\n/**\n * Copies data from an mxn array to interleaved data array of size n*m\n * @param {Array}      channels An mxn array containing m TypedArrays with length n\n * @param {TypedArray} targetInterleaved A TypedArray to write interleaved data to\n */\n\nfunction copyChannelsToInterleaved(channels, targetInterleaved) {\n  if (targetInterleaved.length < channels[0].length * channels.length) throw Error('incorrect channel lengths');\n  var interleavedPos = 0;\n\n  for (var i = 0; i < channels[0].length; i++) {\n    for (var j = 0; j < channels.length; j++) {\n      targetInterleaved[interleavedPos++] = channels[j][i];\n    }\n  }\n}\n/**\n * converts and *scales* TypedArray to Float32 where samples are scaled from \n * TypedArray.minValue < n < TypedArray.maxValue to -1 < n < 1\n *\n * @param  {TypedArray} data A TypedArray containing audio samples\n * @return {TypedArray}      The float32 representations scaled to -1 < n < 1\n */\n\nfunction toFloat32(data) {\n  var divisor = maxValueForTypedArray(data);\n  var float32 = new Float32Array(data.length);\n\n  switch (data.constructor) {\n    case Float32Array:\n      return data;\n\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n      for (var i = 0; i < data.length; i++) {\n        float32[i] = data[i] / divisor;\n      }\n\n      break;\n\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n      for (var _i = 0; _i < data.length; _i++) {\n        float32[_i] = (data[_i] - divisor) / divisor;\n      }\n\n  }\n\n  return float32;\n}\n/**\n * Get the maximum value which can be stored in the given TypedArray\n *\n * @param  {TypedArray} data A TypedArray containing audio samples\n * @return {Number}          The max value which can be stored in array\n */\n\nfunction maxValueForTypedArray(array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return 1;\n\n    case Int8Array:\n    case Uint8Array:\n      return 127;\n\n    case Int16Array:\n    case Uint16Array:\n      return 32767;\n\n    case Int32Array:\n    case Uint32Array:\n      return 2147483647;\n\n    default:\n      throw \"Unsupport data type \".concat(array.constructor);\n  }\n}\n\n//# sourceURL=webpack://FeederNode/./src/util.js?");

/***/ }),

/***/ "./src/worker-resampler.js":
/*!*********************************!*\
  !*** ./src/worker-resampler.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ createWorkerResampler\n/* harmony export */ });\n/* harmony import */ var _abstract_processor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-processor */ \"./src/abstract-processor.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * Initializes a WebWorker (which initializes the web assembly module), and then once init complete,\n * resolve() with a new instance of WorkerResampler\n *\n * *** Unexpected Behavior ***\n * If the following sequence is executed:\n * 1) create AudioContext\n * 2) createWorkerResampler\n * 3) createScriptProcessorNode\n *\n * Script processor node will silently fail to intialize the AudioContext IN SAFARI. I suspect that this\n * is because audio needs to be played in response to a gesture, and by running createWorkerResampler,\n * we're effectly terminating that behavior because we're waiting for a message from message channel.\n *\n * @param { Number } nChannels        The number of input and output channels\n * @param { Number } inputSampleRate  Sample rate of incoming audio\n * @param { Number } outputSampleRate Sample rate which outgoing audio must be\n * @param { Number } converterType    One of libsamplerate.ConverterType:\n *                                    http://www.mega-nerd.com/SRC/api_misc.html#Converters\n * @param { String } pathToWorker     Path from server root to feeder-node.worker.js\n * @param { String } pathToWorklet    Path from server root to libsamplerate.wasm\n * \n */\n\nfunction createWorkerResampler(nChannels, inputSampleRate, outputSampleRate, converterType, pathToWorker, pathToWasm) {\n  return new Promise(function (resolve, reject) {\n    var worker = new Worker(pathToWorker);\n\n    worker.onmessage = function (e) {\n      resolve(new WorkerResampler(nChannels, inputSampleRate, outputSampleRate, converterType, worker));\n    };\n\n    worker.postMessage({\n      command: 'init',\n      inputSampleRate: inputSampleRate,\n      outputSampleRate: outputSampleRate,\n      nChannels: nChannels,\n      converterType: converterType,\n      pathToWasm: pathToWasm\n    }); // resolve();\n  });\n}\n/** \n * Class that passes audio data to a Web Worker to be resampled. If client is also using AudioWorklet\n * and AudioWorkletBackend, passes data directly from worker thread to audio thread via MessagePort\n */\n\nvar WorkerResampler = /*#__PURE__*/function (_AbstractProcessor) {\n  _inherits(WorkerResampler, _AbstractProcessor);\n\n  var _super = _createSuper(WorkerResampler);\n\n  /**\n   * Constructor. This *should not* be called; use create() instead\n   * \n   * @param { Number } nChannels        The number of input and output channels\n   * @param { Number } inputSampleRate  Sample rate of incoming audio\n   * @param { Number } outputSampleRate Sample rate which outgoing audio must be\n   * @param { Number } converterType    One of libsamplerate.ConverterType:\n   *                                    http://www.mega-nerd.com/SRC/api_misc.html#Converters\n   * @param { Worker } worker           Web Worker where the actually conversaion happens\n   */\n  function WorkerResampler(nChannels, inputSampleRate, outputSampleRate, converterType, worker) {\n    var _this;\n\n    _classCallCheck(this, WorkerResampler);\n\n    _this = _super.call(this, inputSampleRate, outputSampleRate);\n    _this.worker = worker;\n    _this.worker.onmessage = _this._onMessage.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Passes data off to this.worker for resampling\n   *\n   * @param {ArrayBuffer} interleavedFloat32Data A float32Array of interleaved/mono audio data\n   */\n\n\n  _createClass(WorkerResampler, [{\n    key: \"processBatch\",\n    value: function processBatch(interleavedFloat32Data) {\n      this.worker.postMessage({\n        command: 'feed',\n        data: interleavedFloat32Data\n      }, [interleavedFloat32Data.buffer]);\n    }\n    /**\n     * Sets a MessageChannel Port to send processed data thru. If this is set, the worker send processed\n     * data thru the message port, bypassing this.onProcessed()\n     * \n     * @param { MessagePort } port port1 or port2 from a MessageChannel\n     */\n\n  }, {\n    key: \"setPort\",\n    value: function setPort(port) {\n      this.worker.postMessage({\n        command: 'connect'\n      }, [port]);\n    }\n    /**\n     * Called by the worker when a batch has been successfully resampled\n     *\n     * @param {Event} e https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\n     */\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(e) {\n      this.onProcessed(e.data);\n    }\n  }]);\n\n  return WorkerResampler;\n}(_abstract_processor__WEBPACK_IMPORTED_MODULE_0__.default);\n\n//# sourceURL=webpack://FeederNode/./src/worker-resampler.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/feeder-node-create.js");
/******/ })()
;
});